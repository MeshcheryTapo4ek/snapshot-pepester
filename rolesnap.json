{
  "Collected Domain": {
    "src/rolesnap/core/models.py": "from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Set\n\n\n@dataclass(frozen=True)\nclass Role:\n    \"\"\"Role definition (new schema).\"\"\"\n    help: str = \"\"\n    # External API surface of the role\n    external_ports: List[str] = field(default_factory=list)\n    external_domain: List[str] = field(default_factory=list)\n    # Internal implementation\n    internal_logic: List[str] = field(default_factory=list)\n    # Task sets\n    base_tasks: List[str] = field(default_factory=list)\n    advanced_tasks: List[str] = field(default_factory=list)\n    # Documentation sources (relative or absolute, arbitrary formats accepted)\n    docs: List[str] = field(default_factory=list)\n    # Dependencies\n    imports: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass Settings:\n    \"\"\"Global settings loaded from YAML.\"\"\"\n    exclude_dirs: Set[str] = field(default_factory=set)\n    utils_dirs: List[str] = field(default_factory=list)\n    project_root: Optional[str] = None  # absolute filesystem path to the project root\n    docs_root: Optional[str] = None     # absolute filesystem path to top-level DOCS folder (sibling to project)\n\n\n@dataclass(frozen=True)\nclass Config:\n    \"\"\"Full config bundle.\"\"\"\n    roles: Dict[str, Role] = field(default_factory=dict)\n    settings: Settings = field(default_factory=Settings)\n"
  },
  "Collected Ports": {
    "src/rolesnap/cli.py": "from __future__ import annotations\n\nimport argparse\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nfrom dotenv import load_dotenv\nfrom rolesnap import __version__\nfrom rolesnap.core.engine import create_snapshot\nfrom rolesnap.core.paths import remove_pycache\nfrom rolesnap.core.planner import collect_role_categories\nfrom rolesnap.core.selfscan import compute_self_scan_inputs\nfrom rolesnap.core.yaml_loader import load_config_from_yaml, load_roles_from_yaml\nfrom rolesnap.logging import console\n\nBANNER = r\"\"\"\n ____            _           _   \n|  _ \\ ___  _ __| |_ ___ _ __| |_ \n| |_) / _ \\| '__| __/ _ \\ '__| __|\n|  _ < (_) | |  | ||  __/ |  | |_ \n|_| \\_\\___/|_|   \\__\\___|_|   \\__|\n\"\"\"\n\ndef _load_project_root(cfg_path: Path) -> Path:\n    cfg = load_config_from_yaml(cfg_path)\n    pr = cfg.settings.project_root\n    return Path(pr).expanduser().resolve() if pr else Path.cwd().resolve()\n\ndef _load_docs_root(cfg_path: Path) -> Optional[Path]:\n    cfg = load_config_from_yaml(cfg_path)\n    dr = cfg.settings.docs_root\n    return Path(dr).expanduser().resolve() if dr else None\n\ndef _resolve_config_path(cwd: Path, cli_config: Optional[str]) -> Path:\n    if cli_config:\n        p = Path(cli_config).expanduser()\n        if not p.is_absolute():\n            p = (cwd / p).resolve()\n        if not p.is_file():\n            console.print(f\"--config file not found: {p}\", style=\"error\")\n            raise SystemExit(2)\n        console.print(f\"Using config from --config: [path]{p}[/path]\", style=\"info\")\n        return p\n\n    env_val = os.getenv(\"ROLESNAP_CONFIG\")\n    if not env_val:\n        console.print(\"ROLESNAP_CONFIG is not set and --config is not provided.\", style=\"error\")\n        console.print(\"Hint: add 'ROLESNAP_CONFIG=./rolesnap.yaml' to your .env or pass --config /abs/path/to/rolesnap.yaml\", style=\"muted\")\n        raise SystemExit(2)\n\n    p = Path(env_val).expanduser()\n    if not p.is_absolute():\n        p = (cwd / p).resolve()\n    if not p.is_file():\n        console.print(f\"ROLESNAP_CONFIG points to non-existing file: {p}\", style=\"error\")\n        raise SystemExit(2)\n\n    console.print(f\"Using config from ENV ROLESNAP_CONFIG: [path]{p}[/path]\", style=\"info\")\n    return p\n\ndef _common_after_config(cfg_path: Path) -> tuple[Path, Optional[Path]]:\n    project_root = _load_project_root(cfg_path)\n    docs_root = _load_docs_root(cfg_path)\n    console.print(f\"Project root: [path]{project_root}[/path]\", style=\"muted\")\n    if docs_root:\n        console.print(f\"Docs root:    [path]{docs_root}[/path]\", style=\"muted\")\n    console.print(f\"Using config: [path]{cfg_path}[/path]\", style=\"muted\")\n    return project_root, docs_root\n\ndef _cmd_full(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    remove_pycache(project_root)\n    categories: Dict[str, List[str]] = {\"Full Project\": [project_root.as_posix()]}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Full Project\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_role(cfg_path: Path, role_name: str, include_utils: bool, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, docs_root = _common_after_config(cfg_path)\n    cfg = load_config_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = collect_role_categories(\n        roles=cfg.roles,\n        selected_role=role_name,\n        include_utils=include_utils,\n        utils_dirs=cfg.settings.utils_dirs,\n    )\n    category_roots = {k: (docs_root if k == \"Docs\" and docs_root else project_root) for k in categories}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=cfg.settings.exclude_dirs,\n        category_roots=category_roots,\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_selfscan(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    _ = load_roles_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = {\n        \"Self-Scan\": compute_self_scan_inputs(\n            project_root=project_root,\n            cli_file=Path(__file__).resolve().parent.parent,\n            config_path=cfg_path,\n        )\n    }\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Self-Scan\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_validate(cfg_path: Path) -> None:\n    cfg = load_config_from_yaml(cfg_path)\n    missing = []\n    pr = Path(cfg.settings.project_root or Path.cwd()).resolve()\n    def _check(paths: list[str]):\n        for raw in paths:\n            p = Path(raw)\n            if not p.is_absolute():\n                p = (pr / raw).resolve()\n            if not p.exists():\n                missing.append(raw)\n    for name, role in cfg.roles.items():\n        _check(role.external_ports + role.external_domain + role.internal_logic + role.base_tasks + role.advanced_tasks + role.docs)\n    if missing:\n        console.print(\"Config valid, but missing paths:\", style=\"warn\")\n        for m in sorted(set(missing)):\n            console.print(f\" - {m}\", style=\"path\")\n        raise SystemExit(2)\n    console.print(f\"Config OK. Roles: {', '.join(sorted(cfg.roles.keys()))}\", style=\"success\")\n\ndef build_arg_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description=\"Create a structured JSON snapshot grouped by categories.\")\n    parser.add_argument(\"--config\", type=str, default=None, help=\"Path to rolesnap.yaml. If not set, uses ROLESNAP_CONFIG from .env/env.\")\n    parser.add_argument(\"--hide-files\", action=\"store_true\", help=\"Do NOT include file contents (paths only).\")\n    parser.add_argument(\"--no-banner\", action=\"store_true\", help=\"Do not display the banner.\")\n    parser.add_argument(\"--version\", action=\"store_true\", help=\"Display the version and exit.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", help=\"Minimal output, no banner or progress.\")\n    parser.add_argument(\"--output\", type=Path, default=None, help=\"Path to write the snapshot to.\")\n    parser.add_argument(\"--max-bytes\", type=int, default=None, help=\"Truncate file contents to N bytes.\")\n    parser.add_argument(\"--no-color\", action=\"store_true\", help=\"Disable color output.\")\n\n    subs = parser.add_subparsers(dest=\"cmd\")\n\n    p_full = subs.add_parser(\"full\", help=\"Scan entire project_root with excludes.\")\n\n    p_role = subs.add_parser(\"role\", help=\"Scan a single role defined in rolesnap.yaml.\")\n    p_role.add_argument(\"name\", type=str, help=\"Role name to scan.\")\n    p_role.add_argument(\"--include-utils\", action=\"store_true\", help=\"Include 'utils' dirs into Internal Logic.\")\n\n    p_self = subs.add_parser(\"selfscan\", help=\"Scan the rolesnap tool itself.\")\n\n    p_val = subs.add_parser(\"validate\", help=\"Validate rolesnap.yaml and paths.\")\n\n    return parser\n\ndef main() -> None:\n    parser = build_arg_parser()\n    args = parser.parse_args()\n\n    if args.no_color or not os.sys.stdout.isatty():\n        from rolesnap.logging import reinit_console\n        reinit_console(color_system=None)\n\n    if args.quiet:\n        console.quiet = True\n\n    if args.version:\n        console.print(f\"rolesnap version {__version__}\", style=\"info\")\n        raise SystemExit(0)\n\n    if not args.no_banner and not args.quiet:\n        console.print(BANNER, style=\"muted\")\n\n    load_dotenv(override=False)\n    cwd = Path.cwd().resolve()\n    cfg_path = _resolve_config_path(cwd=cwd, cli_config=args.config)\n    show_files: bool = not bool(args.hide_files)\n    quiet: bool = args.quiet\n\n    if args.cmd == \"validate\":\n        _cmd_validate(cfg_path)\n        return\n\n    if args.cmd == \"full\":\n        _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"role\":\n        _cmd_role(cfg_path, args.name, args.include_utils, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"selfscan\":\n        _cmd_selfscan(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n\n    # default: full\n    _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  "Internal Logic": {
    "src/rolesnap/__init__.py": "from importlib.metadata import version, PackageNotFoundError\n\n\ntry:\n    __version__: str = version(\"rolesnap\")\nexcept PackageNotFoundError:\n    __version__ = \"0.0.0\"\n",
    "src/rolesnap/cli.py": "from __future__ import annotations\n\nimport argparse\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nfrom dotenv import load_dotenv\nfrom rolesnap import __version__\nfrom rolesnap.core.engine import create_snapshot\nfrom rolesnap.core.paths import remove_pycache\nfrom rolesnap.core.planner import collect_role_categories\nfrom rolesnap.core.selfscan import compute_self_scan_inputs\nfrom rolesnap.core.yaml_loader import load_config_from_yaml, load_roles_from_yaml\nfrom rolesnap.logging import console\n\nBANNER = r\"\"\"\n ____            _           _   \n|  _ \\ ___  _ __| |_ ___ _ __| |_ \n| |_) / _ \\| '__| __/ _ \\ '__| __|\n|  _ < (_) | |  | ||  __/ |  | |_ \n|_| \\_\\___/|_|   \\__\\___|_|   \\__|\n\"\"\"\n\ndef _load_project_root(cfg_path: Path) -> Path:\n    cfg = load_config_from_yaml(cfg_path)\n    pr = cfg.settings.project_root\n    return Path(pr).expanduser().resolve() if pr else Path.cwd().resolve()\n\ndef _load_docs_root(cfg_path: Path) -> Optional[Path]:\n    cfg = load_config_from_yaml(cfg_path)\n    dr = cfg.settings.docs_root\n    return Path(dr).expanduser().resolve() if dr else None\n\ndef _resolve_config_path(cwd: Path, cli_config: Optional[str]) -> Path:\n    if cli_config:\n        p = Path(cli_config).expanduser()\n        if not p.is_absolute():\n            p = (cwd / p).resolve()\n        if not p.is_file():\n            console.print(f\"--config file not found: {p}\", style=\"error\")\n            raise SystemExit(2)\n        console.print(f\"Using config from --config: [path]{p}[/path]\", style=\"info\")\n        return p\n\n    env_val = os.getenv(\"ROLESNAP_CONFIG\")\n    if not env_val:\n        console.print(\"ROLESNAP_CONFIG is not set and --config is not provided.\", style=\"error\")\n        console.print(\"Hint: add 'ROLESNAP_CONFIG=./rolesnap.yaml' to your .env or pass --config /abs/path/to/rolesnap.yaml\", style=\"muted\")\n        raise SystemExit(2)\n\n    p = Path(env_val).expanduser()\n    if not p.is_absolute():\n        p = (cwd / p).resolve()\n    if not p.is_file():\n        console.print(f\"ROLESNAP_CONFIG points to non-existing file: {p}\", style=\"error\")\n        raise SystemExit(2)\n\n    console.print(f\"Using config from ENV ROLESNAP_CONFIG: [path]{p}[/path]\", style=\"info\")\n    return p\n\ndef _common_after_config(cfg_path: Path) -> tuple[Path, Optional[Path]]:\n    project_root = _load_project_root(cfg_path)\n    docs_root = _load_docs_root(cfg_path)\n    console.print(f\"Project root: [path]{project_root}[/path]\", style=\"muted\")\n    if docs_root:\n        console.print(f\"Docs root:    [path]{docs_root}[/path]\", style=\"muted\")\n    console.print(f\"Using config: [path]{cfg_path}[/path]\", style=\"muted\")\n    return project_root, docs_root\n\ndef _cmd_full(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    remove_pycache(project_root)\n    categories: Dict[str, List[str]] = {\"Full Project\": [project_root.as_posix()]}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Full Project\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_role(cfg_path: Path, role_name: str, include_utils: bool, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, docs_root = _common_after_config(cfg_path)\n    cfg = load_config_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = collect_role_categories(\n        roles=cfg.roles,\n        selected_role=role_name,\n        include_utils=include_utils,\n        utils_dirs=cfg.settings.utils_dirs,\n    )\n    category_roots = {k: (docs_root if k == \"Docs\" and docs_root else project_root) for k in categories}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=cfg.settings.exclude_dirs,\n        category_roots=category_roots,\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_selfscan(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    _ = load_roles_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = {\n        \"Self-Scan\": compute_self_scan_inputs(\n            project_root=project_root,\n            cli_file=Path(__file__).resolve().parent.parent,\n            config_path=cfg_path,\n        )\n    }\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Self-Scan\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_validate(cfg_path: Path) -> None:\n    cfg = load_config_from_yaml(cfg_path)\n    missing = []\n    pr = Path(cfg.settings.project_root or Path.cwd()).resolve()\n    def _check(paths: list[str]):\n        for raw in paths:\n            p = Path(raw)\n            if not p.is_absolute():\n                p = (pr / raw).resolve()\n            if not p.exists():\n                missing.append(raw)\n    for name, role in cfg.roles.items():\n        _check(role.external_ports + role.external_domain + role.internal_logic + role.base_tasks + role.advanced_tasks + role.docs)\n    if missing:\n        console.print(\"Config valid, but missing paths:\", style=\"warn\")\n        for m in sorted(set(missing)):\n            console.print(f\" - {m}\", style=\"path\")\n        raise SystemExit(2)\n    console.print(f\"Config OK. Roles: {', '.join(sorted(cfg.roles.keys()))}\", style=\"success\")\n\ndef build_arg_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description=\"Create a structured JSON snapshot grouped by categories.\")\n    parser.add_argument(\"--config\", type=str, default=None, help=\"Path to rolesnap.yaml. If not set, uses ROLESNAP_CONFIG from .env/env.\")\n    parser.add_argument(\"--hide-files\", action=\"store_true\", help=\"Do NOT include file contents (paths only).\")\n    parser.add_argument(\"--no-banner\", action=\"store_true\", help=\"Do not display the banner.\")\n    parser.add_argument(\"--version\", action=\"store_true\", help=\"Display the version and exit.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", help=\"Minimal output, no banner or progress.\")\n    parser.add_argument(\"--output\", type=Path, default=None, help=\"Path to write the snapshot to.\")\n    parser.add_argument(\"--max-bytes\", type=int, default=None, help=\"Truncate file contents to N bytes.\")\n    parser.add_argument(\"--no-color\", action=\"store_true\", help=\"Disable color output.\")\n\n    subs = parser.add_subparsers(dest=\"cmd\")\n\n    p_full = subs.add_parser(\"full\", help=\"Scan entire project_root with excludes.\")\n\n    p_role = subs.add_parser(\"role\", help=\"Scan a single role defined in rolesnap.yaml.\")\n    p_role.add_argument(\"name\", type=str, help=\"Role name to scan.\")\n    p_role.add_argument(\"--include-utils\", action=\"store_true\", help=\"Include 'utils' dirs into Internal Logic.\")\n\n    p_self = subs.add_parser(\"selfscan\", help=\"Scan the rolesnap tool itself.\")\n\n    p_val = subs.add_parser(\"validate\", help=\"Validate rolesnap.yaml and paths.\")\n\n    return parser\n\ndef main() -> None:\n    parser = build_arg_parser()\n    args = parser.parse_args()\n\n    if args.no_color or not os.sys.stdout.isatty():\n        from rolesnap.logging import reinit_console\n        reinit_console(color_system=None)\n\n    if args.quiet:\n        console.quiet = True\n\n    if args.version:\n        console.print(f\"rolesnap version {__version__}\", style=\"info\")\n        raise SystemExit(0)\n\n    if not args.no_banner and not args.quiet:\n        console.print(BANNER, style=\"muted\")\n\n    load_dotenv(override=False)\n    cwd = Path.cwd().resolve()\n    cfg_path = _resolve_config_path(cwd=cwd, cli_config=args.config)\n    show_files: bool = not bool(args.hide_files)\n    quiet: bool = args.quiet\n\n    if args.cmd == \"validate\":\n        _cmd_validate(cfg_path)\n        return\n\n    if args.cmd == \"full\":\n        _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"role\":\n        _cmd_role(cfg_path, args.name, args.include_utils, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"selfscan\":\n        _cmd_selfscan(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n\n    # default: full\n    _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "src/rolesnap/constants.py": "from __future__ import annotations\n\nfrom typing import List, Set\n\n# Defaults kept as fallback; real values should come from YAML settings\nDEFAULT_EXCLUDE_DIRS: Set[str] = {\n    \".git\",\n    \".venv\",\n    \"logs\",\n    \".env\",\n    \"__pycache__\",\n    \"build\",\n    \"dist\",\n    \".mypy_cache\",\n    \".pytest_cache\",\n}\n\nDEFAULT_UTILS_DIRS: List[str] = []\n",
    "src/rolesnap/core/__init__.py": "",
    "src/rolesnap/core/engine.py": "from __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Set\n\nfrom rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeElapsedColumn\nfrom ..logging import console\nfrom .paths import resolve_scan_path, safe_rel_key\n\nBINARY_EXTENSIONS = {\n    \".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".ico\", \".tif\", \".tiff\",\n    \".pdf\", \".doc\", \".docx\", \".xls\", \".xlsx\", \".ppt\", \".pptx\",\n    \".zip\", \".tar\", \".gz\", \".7z\", \".rar\",\n    \".exe\", \".dll\", \".so\", \".a\", \".lib\", \".o\", \".obj\",\n    \".pyc\", \".pyd\",\n    \".ipynb\",\n}\n\ndef create_snapshot(\n    project_root: Path,\n    output_file: Path,\n    categories: Dict[str, List[str]],\n    show_files: bool,\n    exclude_dirs: Set[str],\n    category_roots: Optional[Dict[str, Path]] = None,\n    max_bytes: Optional[int] = None,\n    quiet: bool = False,\n) -> None:\n    \"\"\"\n    Create a structured snapshot JSON grouped by categories.\n    \"\"\"\n    if not categories:\n        console.print(\"No categories provided. Nothing to do.\", style=\"warn\")\n        return\n\n    all_counts: Dict[str, int] = {}\n    snapshot: Dict[str, Dict[str, str]] = {}\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TextColumn(\"{task.completed}/{task.total}\"),\n        TimeElapsedColumn(),\n        console=console,\n        transient=False,\n        disable=quiet,\n    ) as progress:\n        for cat, raw_items in categories.items():\n            if not raw_items:\n                continue\n\n            root_for_cat = (category_roots or {}).get(cat, project_root)\n\n            resolved_paths: List[Path] = []\n            seen: Set[Path] = set()\n            for raw in raw_items:\n                p = resolve_scan_path(root_for_cat, raw)\n                rp = p.resolve()\n                if rp in seen:\n                    continue\n                seen.add(rp)\n                resolved_paths.append(rp)\n\n            if not quiet:\n                pretty_sources = \", \".join(safe_rel_key(root_for_cat, p) for p in resolved_paths)\n                console.print(f\"[category]{cat}[/category] from [path]{pretty_sources}[/path]\")\n\n            cat_data: Dict[str, str] = {}\n            files_list: List[Path] = []\n\n            for scan_path in resolved_paths:\n                if not scan_path.exists():\n                    if not quiet:\n                        console.print(f\"Not found, skipping: {scan_path}\", style=\"warn\")\n                    continue\n                if scan_path.is_dir():\n                    files_list.extend([p for p in scan_path.rglob(\"*\") if p.is_file()])\n                else:\n                    files_list.append(scan_path)\n\n            files_list = [\n                p for p in files_list\n                if not any(part in exclude_dirs for part in p.parts)\n                and p.resolve() != output_file.resolve()\n                and p.suffix not in BINARY_EXTENSIONS\n            ]\n\n            task_id = progress.add_task(f\"Scanning {cat}\", total=len(files_list))\n\n            for path in files_list:\n                key = safe_rel_key(root_for_cat, path)\n                try:\n                    if show_files:\n                        content = path.read_text(encoding=\"utf-8\")\n                        if max_bytes and len(content) > max_bytes:\n                            content = content[:max_bytes]\n                    else:\n                        content = \"<hidden>\"\n\n                    cat_data[key] = content\n                except UnicodeDecodeError:\n                    pass\n                except Exception as e:\n                    if not quiet:\n                        console.print(f\"Error reading file {path}: {e}\", style=\"error\")\n                finally:\n                    progress.advance(task_id)\n\n            if not files_list and not cat_data and not quiet:\n                dir_key = safe_rel_key(root_for_cat, resolved_paths[0])\n                cat_data[dir_key] = \"<empty_dir>\"\n\n            snapshot[cat] = dict(sorted(cat_data.items()))\n            all_counts[cat] = len(cat_data)\n\n    try:\n        output_file.write_text(\n            json.dumps(snapshot, indent=2, ensure_ascii=False),\n            encoding=\"utf-8\",\n        )\n        if not quiet:\n            total = sum(all_counts.values())\n            console.print(f\"Snapshot created with {total} file(s) across {len(snapshot)} categor(ies).\", style=\"success\")\n            console.print(f\"Output file: [path]{output_file}[/path]\", style=\"muted\")\n    except Exception as e:\n        console.print(f\"Failed to write snapshot file: {e}\", style=\"error\")\n",
    "src/rolesnap/core/models.py": "from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Set\n\n\n@dataclass(frozen=True)\nclass Role:\n    \"\"\"Role definition (new schema).\"\"\"\n    help: str = \"\"\n    # External API surface of the role\n    external_ports: List[str] = field(default_factory=list)\n    external_domain: List[str] = field(default_factory=list)\n    # Internal implementation\n    internal_logic: List[str] = field(default_factory=list)\n    # Task sets\n    base_tasks: List[str] = field(default_factory=list)\n    advanced_tasks: List[str] = field(default_factory=list)\n    # Documentation sources (relative or absolute, arbitrary formats accepted)\n    docs: List[str] = field(default_factory=list)\n    # Dependencies\n    imports: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass Settings:\n    \"\"\"Global settings loaded from YAML.\"\"\"\n    exclude_dirs: Set[str] = field(default_factory=set)\n    utils_dirs: List[str] = field(default_factory=list)\n    project_root: Optional[str] = None  # absolute filesystem path to the project root\n    docs_root: Optional[str] = None     # absolute filesystem path to top-level DOCS folder (sibling to project)\n\n\n@dataclass(frozen=True)\nclass Config:\n    \"\"\"Full config bundle.\"\"\"\n    roles: Dict[str, Role] = field(default_factory=dict)\n    settings: Settings = field(default_factory=Settings)\n",
    "src/rolesnap/core/paths.py": "from __future__ import annotations\n\nimport shutil\nfrom pathlib import Path\n\nfrom ..logging import console\n\ndef resolve_scan_path(root: Path, raw: str) -> Path:\n    \"\"\"\n    Resolve a raw path from YAML against the provided project root.\n    - Absolute 'raw' -> returned as-is.\n    - Relative 'raw' -> merged with 'root' by removing the longest overlap\n      between the suffix of 'root.parts' and prefix of 'raw.parts'.\n      This avoids duplicated segments like 'trading_agent/trading_agent/...'.\n    \"\"\"\n    p = Path(raw).expanduser()\n    if p.is_absolute():\n        return p.resolve()\n\n    raw_parts = [part for part in p.parts if part not in (\".\", \"\")]\n    root_parts = list(root.resolve().parts)\n\n    # Find longest l > 0 where raw_parts[:l] == root_parts[-l:]\n    max_l = 0\n    max_l_candidate = min(len(raw_parts), len(root_parts))\n    for l in range(1, max_l_candidate + 1):\n        if raw_parts[:l] == root_parts[-l:]:\n            max_l = l\n\n    # If overlap exists, drop the overlapping prefix from raw\n    tail_parts = raw_parts[max_l:] if max_l > 0 else raw_parts\n    merged = Path(*root_parts) / Path(*tail_parts) if tail_parts else Path(*root_parts)\n    return merged.resolve()\n\n\ndef safe_rel_key(root: Path, path: Path) -> str:\n    \"\"\"Prefer a key relative to project root, otherwise absolute POSIX.\"\"\"\n    try:\n        return path.relative_to(root).as_posix()\n    except Exception:\n        return path.as_posix()\n\n\ndef remove_pycache(root: Path) -> None:\n    \"\"\"Recursively remove all '__pycache__' directories under the root.\"\"\"\n    console.print(f\"ðŸ§¹ Removing __pycache__ folders in '{root}'...\", style=\"muted\")\n    count = 0\n    for path in root.rglob(\"__pycache__\"):\n        if path.is_dir():\n            shutil.rmtree(path)\n            count += 1\n    if count > 0:\n        console.print(f\"Found and removed {count} __pycache__ folder(s).\", style=\"muted\")\n\n\ndef _walk_up(p: Path) -> list[Path]:\n    acc: list[Path] = []\n    cur = p\n    while True:\n        acc.append(cur)\n        if cur.parent == cur:\n            break\n        cur = cur.parent\n    return acc\n",
    "src/rolesnap/core/planner.py": "from __future__ import annotations\n\nfrom typing import Dict, Iterable, List, Set\n\nfrom .models import Role\n\n\ndef collect_role_categories(\n    roles: Dict[str, Role],\n    selected_role: str,\n    include_utils: bool,\n    utils_dirs: List[str],\n) -> Dict[str, List[str]]:\n    \"\"\"\n    Build categorized scan sources for a role using the new schema.\n\n    Categories:\n      - Collected Domain        = role.external_domain + sum(import.external_domain)\n      - Collected Ports         = role.external_ports  + sum(import.external_ports)\n      - Internal Logic          = role.internal_logic (+ utils if include_utils)\n      - Base Tasks              = role.base_tasks\n      - Collected Base Tasks    = sum(import.base_tasks)\n      - Advanced Tasks          = role.advanced_tasks\n      - Docs                    = role.docs (own docs only)\n    \"\"\"\n    if selected_role not in roles:\n        raise ValueError(f\"Unknown role '{selected_role}'. Available: {', '.join(sorted(roles))}\")\n\n    r: Role = roles[selected_role]\n\n    def add_all(target: Set[str], items: Iterable[str]) -> None:\n        for it in items:\n            if it:\n                target.add(it.rstrip(\"/\"))\n\n    # Own sets\n    domain_self: Set[str] = set()\n    ports_self: Set[str] = set()\n    internal_self: Set[str] = set()\n    base_self: Set[str] = set()\n    adv_self: Set[str] = set()\n    docs_self: Set[str] = set()\n\n    add_all(domain_self, r.external_domain)\n    add_all(ports_self, r.external_ports)\n    add_all(internal_self, r.internal_logic)\n    add_all(base_self, r.base_tasks)\n    add_all(adv_self, r.advanced_tasks)\n    add_all(docs_self, r.docs)\n    if include_utils:\n        add_all(internal_self, utils_dirs)\n\n    # Imported contributions\n    domain_imports: Set[str] = set()\n    ports_imports: Set[str] = set()\n    base_imports: Set[str] = set()\n\n    for dep_name in r.imports:\n        dep = roles.get(dep_name)\n        if dep is None:\n            raise ValueError(f\"Role '{selected_role}' imports unknown role '{dep_name}'\")\n        add_all(domain_imports, dep.external_domain)\n        add_all(ports_imports, dep.external_ports)\n        add_all(base_imports, dep.base_tasks)\n\n    return {\n        \"Collected Domain\": sorted(domain_self | domain_imports),\n        \"Collected Ports\": sorted(ports_self | ports_imports),\n        \"Internal Logic\": sorted(internal_self),\n        \"Base Tasks\": sorted(base_self),\n        \"Collected Base Tasks\": sorted(base_imports),\n        \"Advanced Tasks\": sorted(adv_self),\n        \"Docs\": sorted(docs_self),\n    }\n",
    "src/rolesnap/core/selfscan.py": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import List, Set\n\nfrom .paths import safe_rel_key\n\ndef compute_self_scan_inputs(project_root: Path, cli_file: Path, config_path: Path) -> List[str]:\n    \"\"\"\n    Build a list of paths so that self-scan covers:\n      - the CLI file,\n      - the rolesnap.core package (resolved dynamically),\n      - the YAML config used.\n    Prefer relative POSIX keys; skip missing entries; deduplicate results.\n    \"\"\"\n    results: List[str] = []\n    seen: Set[str] = set()\n\n    def add(path: Path) -> None:\n        if not path.exists():\n            return\n        key = safe_rel_key(project_root, path)\n        if key in seen:\n            return\n        seen.add(key)\n        results.append(key)\n\n    # 1) CLI file\n    add(cli_file)\n\n    # 2) rolesnap.core package: try import-based resolution first\n    pkg_candidate: Path | None = None\n    try:\n        import rolesnap.core as su\n        pkg_candidate = Path(su.__file__).resolve().parent\n    except Exception:\n        pkg_candidate = None\n\n    if pkg_candidate is not None:\n        add(pkg_candidate)\n\n    # Fallback candidates: project root and CLI directory\n    add(project_root / \"rolesnap\" / \"core\")\n    add(cli_file.parent / \"core\")\n\n    # 3) YAML config\n    add(config_path)\n\n    return results\n",
    "src/rolesnap/core/yaml_loader.py": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Set\n\nimport yaml\n\nfrom .models import Config, Role, Settings\nfrom ..constants import DEFAULT_EXCLUDE_DIRS, DEFAULT_UTILS_DIRS\n\n\ndef _as_str_list(value: object, field_name: str, ctx_name: str) -> List[str]:\n    \"\"\"Normalize to list[str] and validate.\"\"\"\n    if value is None:\n        return []\n    if isinstance(value, str):\n        return [value]\n    if isinstance(value, list):\n        out: List[str] = []\n        for i, v in enumerate(value):\n            if not isinstance(v, str):\n                raise TypeError(\n                    f\"'{ctx_name}': field '{field_name}' element #{i} must be a string, got {type(v).__name__}\"\n                )\n            out.append(v)\n        return out\n    raise TypeError(\n        f\"'{ctx_name}': field '{field_name}' must be a string or list of strings, got {type(value).__name__}\"\n    )\n\n\ndef _as_opt_str(value: object, field_name: str, ctx_name: str) -> Optional[str]:\n    \"\"\"Normalize to Optional[str].\"\"\"\n    if value is None:\n        return None\n    if isinstance(value, str):\n        return value\n    raise TypeError(f\"'{ctx_name}': field '{field_name}' must be a string if provided, got {type(value).__name__}\")\n\n\ndef _validate_roles(roles: Dict[str, Role]) -> None:\n    \"\"\"Ensure imported roles exist and no cycles.\"\"\"\n    for name, role in roles.items():\n        for dep in role.imports:\n            if dep not in roles:\n                raise ValueError(f\"Role '{name}' imports unknown role '{dep}'\")\n\n    visiting: set[str] = set()\n    visited: set[str] = set()\n\n    def dfs(node: str) -> None:\n        if node in visiting:\n            raise ValueError(f\"Import cycle detected at role '{node}'\")\n        if node in visited:\n            return\n        visiting.add(node)\n        for dep in roles[node].imports:\n            dfs(dep)\n        visiting.remove(node)\n        visited.add(node)\n\n    for role_name in roles:\n        if role_name not in visited:\n            dfs(role_name)\n\n\ndef _parse_roles(raw_roles: dict) -> Dict[str, Role]:\n    roles: Dict[str, Role] = {}\n    for name, data in raw_roles.items():\n        if not isinstance(data, dict):\n            raise ValueError(f\"Role '{name}' must be a mapping.\")\n        # Accept both 'docs' and 'DOCS' for convenience\n        docs_val = data.get(\"docs\", data.get(\"DOCS\"))\n        role = Role(\n            help=str(data.get(\"help\", \"\")),\n            external_ports=_as_str_list(data.get(\"external_ports\"), \"external_ports\", name),\n            external_domain=_as_str_list(data.get(\"external_domain\"), \"external_domain\", name),\n            internal_logic=_as_str_list(data.get(\"internal_logic\"), \"internal_logic\", name),\n            base_tasks=_as_str_list(data.get(\"base_tasks\"), \"base_tasks\", name),\n            advanced_tasks=_as_str_list(data.get(\"advanced_tasks\"), \"advanced_tasks\", name),\n            docs=_as_str_list(docs_val, \"docs\", name),\n            imports=_as_str_list(data.get(\"imports\"), \"imports\", name),\n        )\n        roles[name] = role\n    _validate_roles(roles)\n    return roles\n\n\ndef _parse_settings(raw: dict) -> Settings:\n    exclude_dirs: Set[str] = set(DEFAULT_EXCLUDE_DIRS)\n    utils_dirs: List[str] = list(DEFAULT_UTILS_DIRS)\n    project_root: Optional[str] = None\n    docs_root: Optional[str] = None\n\n    s = raw.get(\"settings\")\n    if isinstance(s, dict):\n        if \"exclude_dirs\" in s:\n            exclude_dirs.update(_as_str_list(s[\"exclude_dirs\"], \"exclude_dirs\", \"settings\"))\n        if \"utils_dirs\" in s:\n            utils_dirs = _as_str_list(s[\"utils_dirs\"], \"utils_dirs\", \"settings\")\n        if \"project_root\" in s:\n            project_root = _as_opt_str(s[\"project_root\"], \"project_root\", \"settings\")\n        if \"docs_root\" in s:\n            docs_root = _as_opt_str(s[\"docs_root\"], \"docs_root\", \"settings\")\n\n    return Settings(\n        exclude_dirs=exclude_dirs,\n        utils_dirs=utils_dirs,\n        project_root=project_root,\n        docs_root=docs_root,\n    )\n\n\ndef load_config_from_yaml(config_path: Path) -> Config:\n    \"\"\"Load full config bundle (roles + settings with project_root/docs_root).\"\"\"\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Config not found: {config_path}\")\n\n    raw = yaml.safe_load(config_path.read_text(encoding=\"utf-8\"))\n    if not isinstance(raw, dict) or \"roles\" not in raw or not isinstance(raw[\"roles\"], dict):\n        raise ValueError(\"Invalid YAML structure. Expected root key 'roles' with a mapping.\")\n\n    roles = _parse_roles(raw[\"roles\"])\n    settings = _parse_settings(raw)\n    return Config(roles=roles, settings=settings)\n\n\ndef load_roles_from_yaml(config_path: Path) -> Dict[str, Role]:\n    \"\"\"Backward-compat for existing callers (self-scan).\"\"\"\n    return load_config_from_yaml(config_path).roles\n",
    "src/rolesnap/logging.py": "from __future__ import annotations\nfrom typing import Final\nfrom rich.console import Console\nfrom rich.theme import Theme\n\nTHEME: Final = Theme({\n    \"info\":        \"cyan\",\n    \"success\":     \"green\",\n    \"warn\":        \"yellow\",\n    \"error\":       \"bold red\",\n    \"muted\":       \"dim\",\n    \"path\":        \"magenta\",\n    \"category\":    \"bold blue\",\n})\n\nconsole: Console = Console(theme=THEME)\n\ndef reinit_console(color_system: str = \"auto\"):\n    global console\n    console = Console(theme=THEME, color_system=color_system)\n"
  },
  "Base Tasks": {
    "src/rolesnap/cli.py": "from __future__ import annotations\n\nimport argparse\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nfrom dotenv import load_dotenv\nfrom rolesnap import __version__\nfrom rolesnap.core.engine import create_snapshot\nfrom rolesnap.core.paths import remove_pycache\nfrom rolesnap.core.planner import collect_role_categories\nfrom rolesnap.core.selfscan import compute_self_scan_inputs\nfrom rolesnap.core.yaml_loader import load_config_from_yaml, load_roles_from_yaml\nfrom rolesnap.logging import console\n\nBANNER = r\"\"\"\n ____            _           _   \n|  _ \\ ___  _ __| |_ ___ _ __| |_ \n| |_) / _ \\| '__| __/ _ \\ '__| __|\n|  _ < (_) | |  | ||  __/ |  | |_ \n|_| \\_\\___/|_|   \\__\\___|_|   \\__|\n\"\"\"\n\ndef _load_project_root(cfg_path: Path) -> Path:\n    cfg = load_config_from_yaml(cfg_path)\n    pr = cfg.settings.project_root\n    return Path(pr).expanduser().resolve() if pr else Path.cwd().resolve()\n\ndef _load_docs_root(cfg_path: Path) -> Optional[Path]:\n    cfg = load_config_from_yaml(cfg_path)\n    dr = cfg.settings.docs_root\n    return Path(dr).expanduser().resolve() if dr else None\n\ndef _resolve_config_path(cwd: Path, cli_config: Optional[str]) -> Path:\n    if cli_config:\n        p = Path(cli_config).expanduser()\n        if not p.is_absolute():\n            p = (cwd / p).resolve()\n        if not p.is_file():\n            console.print(f\"--config file not found: {p}\", style=\"error\")\n            raise SystemExit(2)\n        console.print(f\"Using config from --config: [path]{p}[/path]\", style=\"info\")\n        return p\n\n    env_val = os.getenv(\"ROLESNAP_CONFIG\")\n    if not env_val:\n        console.print(\"ROLESNAP_CONFIG is not set and --config is not provided.\", style=\"error\")\n        console.print(\"Hint: add 'ROLESNAP_CONFIG=./rolesnap.yaml' to your .env or pass --config /abs/path/to/rolesnap.yaml\", style=\"muted\")\n        raise SystemExit(2)\n\n    p = Path(env_val).expanduser()\n    if not p.is_absolute():\n        p = (cwd / p).resolve()\n    if not p.is_file():\n        console.print(f\"ROLESNAP_CONFIG points to non-existing file: {p}\", style=\"error\")\n        raise SystemExit(2)\n\n    console.print(f\"Using config from ENV ROLESNAP_CONFIG: [path]{p}[/path]\", style=\"info\")\n    return p\n\ndef _common_after_config(cfg_path: Path) -> tuple[Path, Optional[Path]]:\n    project_root = _load_project_root(cfg_path)\n    docs_root = _load_docs_root(cfg_path)\n    console.print(f\"Project root: [path]{project_root}[/path]\", style=\"muted\")\n    if docs_root:\n        console.print(f\"Docs root:    [path]{docs_root}[/path]\", style=\"muted\")\n    console.print(f\"Using config: [path]{cfg_path}[/path]\", style=\"muted\")\n    return project_root, docs_root\n\ndef _cmd_full(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    remove_pycache(project_root)\n    categories: Dict[str, List[str]] = {\"Full Project\": [project_root.as_posix()]}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Full Project\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_role(cfg_path: Path, role_name: str, include_utils: bool, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, docs_root = _common_after_config(cfg_path)\n    cfg = load_config_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = collect_role_categories(\n        roles=cfg.roles,\n        selected_role=role_name,\n        include_utils=include_utils,\n        utils_dirs=cfg.settings.utils_dirs,\n    )\n    category_roots = {k: (docs_root if k == \"Docs\" and docs_root else project_root) for k in categories}\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=cfg.settings.exclude_dirs,\n        category_roots=category_roots,\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_selfscan(cfg_path: Path, show_files: bool, output: Optional[Path], max_bytes: Optional[int], quiet: bool) -> None:\n    project_root, _ = _common_after_config(cfg_path)\n    _ = load_roles_from_yaml(cfg_path)\n    remove_pycache(project_root)\n    categories = {\n        \"Self-Scan\": compute_self_scan_inputs(\n            project_root=project_root,\n            cli_file=Path(__file__).resolve().parent.parent,\n            config_path=cfg_path,\n        )\n    }\n    create_snapshot(\n        project_root=project_root,\n        output_file=output or project_root / \"rolesnap.json\",\n        categories=categories,\n        show_files=show_files,\n        exclude_dirs=load_config_from_yaml(cfg_path).settings.exclude_dirs,\n        category_roots={\"Self-Scan\": project_root},\n        max_bytes=max_bytes,\n        quiet=quiet,\n    )\n\ndef _cmd_validate(cfg_path: Path) -> None:\n    cfg = load_config_from_yaml(cfg_path)\n    missing = []\n    pr = Path(cfg.settings.project_root or Path.cwd()).resolve()\n    def _check(paths: list[str]):\n        for raw in paths:\n            p = Path(raw)\n            if not p.is_absolute():\n                p = (pr / raw).resolve()\n            if not p.exists():\n                missing.append(raw)\n    for name, role in cfg.roles.items():\n        _check(role.external_ports + role.external_domain + role.internal_logic + role.base_tasks + role.advanced_tasks + role.docs)\n    if missing:\n        console.print(\"Config valid, but missing paths:\", style=\"warn\")\n        for m in sorted(set(missing)):\n            console.print(f\" - {m}\", style=\"path\")\n        raise SystemExit(2)\n    console.print(f\"Config OK. Roles: {', '.join(sorted(cfg.roles.keys()))}\", style=\"success\")\n\ndef build_arg_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description=\"Create a structured JSON snapshot grouped by categories.\")\n    parser.add_argument(\"--config\", type=str, default=None, help=\"Path to rolesnap.yaml. If not set, uses ROLESNAP_CONFIG from .env/env.\")\n    parser.add_argument(\"--hide-files\", action=\"store_true\", help=\"Do NOT include file contents (paths only).\")\n    parser.add_argument(\"--no-banner\", action=\"store_true\", help=\"Do not display the banner.\")\n    parser.add_argument(\"--version\", action=\"store_true\", help=\"Display the version and exit.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", help=\"Minimal output, no banner or progress.\")\n    parser.add_argument(\"--output\", type=Path, default=None, help=\"Path to write the snapshot to.\")\n    parser.add_argument(\"--max-bytes\", type=int, default=None, help=\"Truncate file contents to N bytes.\")\n    parser.add_argument(\"--no-color\", action=\"store_true\", help=\"Disable color output.\")\n\n    subs = parser.add_subparsers(dest=\"cmd\")\n\n    p_full = subs.add_parser(\"full\", help=\"Scan entire project_root with excludes.\")\n\n    p_role = subs.add_parser(\"role\", help=\"Scan a single role defined in rolesnap.yaml.\")\n    p_role.add_argument(\"name\", type=str, help=\"Role name to scan.\")\n    p_role.add_argument(\"--include-utils\", action=\"store_true\", help=\"Include 'utils' dirs into Internal Logic.\")\n\n    p_self = subs.add_parser(\"selfscan\", help=\"Scan the rolesnap tool itself.\")\n\n    p_val = subs.add_parser(\"validate\", help=\"Validate rolesnap.yaml and paths.\")\n\n    return parser\n\ndef main() -> None:\n    parser = build_arg_parser()\n    args = parser.parse_args()\n\n    if args.no_color or not os.sys.stdout.isatty():\n        from rolesnap.logging import reinit_console\n        reinit_console(color_system=None)\n\n    if args.quiet:\n        console.quiet = True\n\n    if args.version:\n        console.print(f\"rolesnap version {__version__}\", style=\"info\")\n        raise SystemExit(0)\n\n    if not args.no_banner and not args.quiet:\n        console.print(BANNER, style=\"muted\")\n\n    load_dotenv(override=False)\n    cwd = Path.cwd().resolve()\n    cfg_path = _resolve_config_path(cwd=cwd, cli_config=args.config)\n    show_files: bool = not bool(args.hide_files)\n    quiet: bool = args.quiet\n\n    if args.cmd == \"validate\":\n        _cmd_validate(cfg_path)\n        return\n\n    if args.cmd == \"full\":\n        _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"role\":\n        _cmd_role(cfg_path, args.name, args.include_utils, show_files, args.output, args.max_bytes, quiet)\n        return\n    if args.cmd == \"selfscan\":\n        _cmd_selfscan(cfg_path, show_files, args.output, args.max_bytes, quiet)\n        return\n\n    # default: full\n    _cmd_full(cfg_path, show_files, args.output, args.max_bytes, quiet)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  "Docs": {
    "README.md": "<empty_dir>"
  }
}